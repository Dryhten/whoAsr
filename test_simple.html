<!DOCTYPE html>
<html>
<head>
    <title>Simple Speech Recognition Test</title>
    <style>
        body { 
            font-family: Arial, sans-serif; 
            margin: 0; 
            padding: 20px; 
            height: 100vh; 
            display: flex; 
            flex-direction: column; 
            box-sizing: border-box;
        }
        .status { 
            margin: 10px 0; 
            padding: 10px; 
            background: #f0f0f0; 
            border-radius: 5px;
        }
        .controls {
            margin: 10px 0;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        button { 
            padding: 10px 20px; 
            margin: 0; 
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
        }
        #startBtn { background: #28a745; color: white; }
        #stopBtn { background: #dc3545; color: white; }
        #reconnectBtn { background: #007bff; color: white; }
        #punctuationBtn { background: #6f42c1; color: white; }
        button:disabled { 
            background: #6c757d; 
            cursor: not-allowed; 
        }
        .results { 
            margin: 10px 0; 
            padding: 10px; 
            background: #f9f9f9; 
            border: 1px solid #ddd;
            border-radius: 5px;
            flex: 1;
            overflow-y: auto;
            min-height: 0;
        }
        .result-item {
            padding: 5px 10px;
            margin: 2px 0;
            border-left: 3px solid #007bff;
            background: white;
            border-radius: 3px;
            font-size: 14px;
            line-height: 1.4;
        }
        .result-item.final {
            border-left-color: #28a745;
            font-weight: bold;
        }
        .result-item.punctuated {
            border-left-color: #6f42c1;
            font-style: normal;
        }
        .result-item.unpunctuated {
            border-left-color: #007bff;
            font-style: italic;
        }
        h1, h3 {
            margin: 10px 0;
        }
        .auto-punctuation-status {
            margin: 5px 0;
            padding: 5px 10px;
            background: #e7f3ff;
            border-radius: 3px;
            font-size: 12px;
            color: #0066cc;
        }
    </style>
</head>
<body>
    <h1>Simple Speech Recognition Test</h1>
    
    <div class="status" id="status">Status: Connecting...</div>
    <div class="auto-punctuation-status" id="autoPunctuationStatus">Auto punctuation: Enabled (10s delay)</div>
    
    <div class="controls">
        <button id="startBtn" onclick="startRecording()" disabled>Start Recording</button>
        <button id="stopBtn" onclick="stopRecording()" disabled>Stop Recording</button>
        <button id="reconnectBtn" onclick="reconnectWebSocket()">Reconnect</button>
        <button id="punctuationBtn" onclick="addPunctuationToResults()" disabled>Add Punctuation</button>
    </div>
    
    <div class="results">
        <h3>Results:</h3>
        <div id="resultsList"></div>
    </div>

    <script>
        let ws = null;
        let mediaRecorder = null;
        let isRecording = false;
        let audioContext = null;
        
        // Auto punctuation variables
        let lastContentUpdate = null;
        let punctuationTimer = null;
        let autoPunctuationEnabled = true;
        const AUTO_PUNCTUATION_DELAY = 10000; // 10 seconds

        function updateStatus(message) {
            document.getElementById('status').textContent = 'Status: ' + message;
        }

        function updateDebug(message) {
            // Only output to console, not to the UI
            console.log(new Date().toLocaleTimeString() + ': ' + message);
        }

        function addResult(text, isFinal) {
            const resultsList = document.getElementById('resultsList');
            
            // If it's a final result, update the last non-final result if exists
            if (isFinal) {
                const lastResult = resultsList.lastElementChild;
                if (lastResult && !lastResult.classList.contains('final')) {
                    lastResult.textContent += text;
                    lastResult.classList.add('final');
                    lastResult.classList.add('unpunctuated');
                    scheduleAutoPunctuation();
                    return;
                }
            }
            
            // Check if there's a non-final result to append to
            const lastResult = resultsList.lastElementChild;
            if (lastResult && !lastResult.classList.contains('final')) {
                // Append to existing result
                lastResult.textContent += text;
            } else {
                // Create new result item
                const resultItem = document.createElement('div');
                resultItem.className = 'result-item unpunctuated' + (isFinal ? ' final' : '');
                resultItem.textContent = text;
                resultsList.appendChild(resultItem);
            }
            
            // Schedule auto punctuation if this is final content
            if (isFinal) {
                scheduleAutoPunctuation();
            }
            
            // Auto scroll to bottom
            resultsList.scrollTop = resultsList.scrollHeight;
        }

        function scheduleAutoPunctuation() {
            if (!autoPunctuationEnabled) return;
            
            // Update the last content update time
            lastContentUpdate = Date.now();
            
            // Clear existing timer
            if (punctuationTimer) {
                clearTimeout(punctuationTimer);
            }
            
            // Set new timer
            punctuationTimer = setTimeout(() => {
                // Check if we should add punctuation (10 seconds have passed since last update)
                if (lastContentUpdate && Date.now() - lastContentUpdate >= AUTO_PUNCTUATION_DELAY) {
                    updateDebug('Auto punctuation triggered after 10 seconds of inactivity');
                    addPunctuationToResults(true); // true indicates auto-triggered
                }
            }, AUTO_PUNCTUATION_DELAY);
            
            updateDebug('Auto punctuation scheduled in 10 seconds');
        }

        function connectWebSocket() {
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsUrl = `${protocol}//${window.location.host}/ws/${Date.now()}`;
            
            updateDebug('Connecting to: ' + wsUrl);
            ws = new WebSocket(wsUrl);
            
            ws.onopen = function() {
                updateStatus('Connected');
                updateDebug('WebSocket connected');
                document.getElementById('startBtn').disabled = false;
                document.getElementById('reconnectBtn').disabled = true;
                updatePunctuationButton();
            };
            
            ws.onmessage = function(event) {
                const data = JSON.parse(event.data);
                updateDebug('Received: ' + JSON.stringify(data));
                
                if (data.type === 'recognition_result') {
                    addResult(data.text, data.is_final);
                } else if (data.type === 'error') {
                    updateStatus('Error: ' + data.message);
                    updateDebug('Error: ' + data.message);
                } else if (data.type === 'status') {
                    updateStatus(data.message);
                    updateDebug('Status: ' + data.message);
                }
            };
            
            ws.onclose = function() {
                updateStatus('Disconnected');
                updateDebug('WebSocket disconnected');
                document.getElementById('startBtn').disabled = true;
                document.getElementById('stopBtn').disabled = true;
                document.getElementById('reconnectBtn').disabled = false;
                updatePunctuationButton();
                
                // Clear auto punctuation timer on disconnect
                if (punctuationTimer) {
                    clearTimeout(punctuationTimer);
                    punctuationTimer = null;
                }
            };
            
            ws.onerror = function(error) {
                updateStatus('Connection error');
                updateDebug('WebSocket error: ' + error);
                document.getElementById('reconnectBtn').disabled = false;
                updatePunctuationButton();
            };
        }

        function reconnectWebSocket() {
            // Close existing connection if any
            if (ws) {
                ws.close();
                ws = null;
            }
            
            // Clear auto punctuation timer
            if (punctuationTimer) {
                clearTimeout(punctuationTimer);
                punctuationTimer = null;
            }
            
            // Clear results
            document.getElementById('resultsList').innerHTML = '';
            lastContentUpdate = null;
            
            // Reconnect
            document.getElementById('reconnectBtn').disabled = true;
            updateStatus('Reconnecting...');
            connectWebSocket();
        }

        async function startRecording() {
            try {
                updateDebug('Requesting microphone access...');
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                
                // Initialize audio context
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                updateDebug('Audio context sample rate: ' + audioContext.sampleRate);
                
                // Use Web Audio API for direct audio capture
                const source = audioContext.createMediaStreamSource(stream);
                const processor = audioContext.createScriptProcessor(4096, 1, 1);
                
                processor.onaudioprocess = function(e) {
                    if (isRecording && ws && ws.readyState === WebSocket.OPEN) {
                        const inputBuffer = e.inputBuffer;
                        const inputData = inputBuffer.getChannelData(0);
                        
                        updateDebug('Audio chunk received, length: ' + inputData.length);
                        
                        // Resample to 16kHz if needed
                        const targetSampleRate = 16000;
                        let audioData = inputData;
                        
                        if (audioContext.sampleRate !== targetSampleRate) {
                            const ratio = audioContext.sampleRate / targetSampleRate;
                            const newLength = Math.floor(inputData.length / ratio);
                            audioData = new Float32Array(newLength);
                            
                            for (let i = 0; i < newLength; i++) {
                                const srcIndex = Math.floor(i * ratio);
                                audioData[i] = inputData[srcIndex];
                            }
                            
                            updateDebug('Resampled audio to 16kHz, new length: ' + audioData.length);
                        }
                        
                        // Convert to base64
                        const base64Audio = btoa(String.fromCharCode(...new Uint8Array(audioData.buffer)));
                        updateDebug('Base64 audio length: ' + base64Audio.length);
                        
                        ws.send(JSON.stringify({
                            type: 'audio_chunk',
                            data: base64Audio
                        }));
                        
                        updateDebug('Audio chunk sent');
                    }
                };
                
                source.connect(processor);
                processor.connect(audioContext.destination);
                
                isRecording = true;
                
                document.getElementById('startBtn').disabled = true;
                document.getElementById('stopBtn').disabled = false;
                updateStatus('Recording...');
                updateDebug('Recording started');
                
                // Send start message
                ws.send(JSON.stringify({ type: 'start_recording' }));
                
                // Store references for cleanup
                mediaRecorder = { stream: stream, source: source, processor: processor };
                
            } catch (error) {
                updateDebug('Error accessing microphone: ' + error.message);
                updateStatus('Microphone access denied');
            }
        }

        function stopRecording() {
            if (mediaRecorder && isRecording) {
                // Stop the audio processing
                if (mediaRecorder.processor) {
                    mediaRecorder.processor.disconnect();
                }
                if (mediaRecorder.source) {
                    mediaRecorder.source.disconnect();
                }
                
                // Stop the media stream
                if (mediaRecorder.stream) {
                    mediaRecorder.stream.getTracks().forEach(track => track.stop());
                }
                
                isRecording = false;
                
                document.getElementById('startBtn').disabled = false;
                document.getElementById('stopBtn').disabled = true;
                updateStatus('Processing final audio...');
                updateDebug('Recording stopped');
                
                // Send stop message
                ws.send(JSON.stringify({ type: 'stop_recording' }));
                
                // Schedule auto punctuation after recording stops
                scheduleAutoPunctuation();
            }
        }

        async function addPunctuationToResults(isAutoTriggered = false) {
            const resultsList = document.getElementById('resultsList');
            const allResults = Array.from(resultsList.querySelectorAll('.result-item'));
            
            if (allResults.length === 0) {
                if (!isAutoTriggered) {
                    updateStatus('No results to add punctuation to');
                }
                return;
            }
            
            // Separate punctuated and unpunctuated content
            const punctuatedItems = allResults.filter(item => item.classList.contains('punctuated'));
            const unpunctuatedItems = allResults.filter(item => !item.classList.contains('punctuated'));
            
            // Get text from unpunctuated items only
            let textToPunctuate = '';
            unpunctuatedItems.forEach(item => {
                textToPunctuate += item.textContent + ' ';
            });
            textToPunctuate = textToPunctuate.trim();
            
            if (textToPunctuate === '') {
                if (!isAutoTriggered) {
                    updateStatus('No new content to punctuate');
                }
                return;
            }
            
            if (!isAutoTriggered) {
                updateStatus('Adding punctuation...');
                document.getElementById('punctuationBtn').disabled = true;
            } else {
                updateDebug('Auto punctuation processing...');
            }
            
            try {
                const response = await fetch('/punctuation/add', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        text: textToPunctuate,
                        force_load: true
                    })
                });
                
                const data = await response.json();
                
                if (data.success) {
                    // Clear only unpunctuated items
                    unpunctuatedItems.forEach(item => item.remove());
                    
                    // Split punctuated text by sentences and add as separate items
                    const sentences = data.punctuated_text.match(/[^。！？.!?]+[。！？.!?]*/g) || [data.punctuated_text];
                    
                    sentences.forEach((sentence, index) => {
                        if (sentence.trim()) {
                            const resultItem = document.createElement('div');
                            resultItem.className = 'result-item final punctuated unpunctuated';
                            resultItem.style.borderLeftColor = '#6f42c1';
                            resultItem.textContent = sentence.trim();
                            resultsList.appendChild(resultItem);
                        }
                    });
                    
                    if (!isAutoTriggered) {
                        updateStatus('Punctuation added successfully');
                    } else {
                        updateDebug('Auto punctuation completed successfully');
                    }
                    updateDebug('Punctuated text: ' + data.punctuated_text);
                    
                    // Reset the auto punctuation timer after successful punctuation
                    lastContentUpdate = null;
                    if (punctuationTimer) {
                        clearTimeout(punctuationTimer);
                        punctuationTimer = null;
                    }
                } else {
                    if (!isAutoTriggered) {
                        updateStatus('Failed to add punctuation: ' + data.message);
                    } else {
                        updateDebug('Auto punctuation failed: ' + data.message);
                    }
                }
            } catch (error) {
                if (!isAutoTriggered) {
                    updateStatus('Error adding punctuation: ' + error.message);
                } else {
                    updateDebug('Auto punctuation error: ' + error.message);
                }
            } finally {
                if (!isAutoTriggered) {
                    document.getElementById('punctuationBtn').disabled = false;
                    updatePunctuationButton();
                }
            }
        }

        function updatePunctuationButton() {
            const resultsList = document.getElementById('resultsList');
            const allResults = resultsList.querySelectorAll('.result-item');
            const punctuationBtn = document.getElementById('punctuationBtn');
            
            // Enable button if there are any results and WebSocket is connected
            if (allResults.length > 0 && ws && ws.readyState === WebSocket.OPEN) {
                punctuationBtn.disabled = false;
            } else {
                punctuationBtn.disabled = true;
            }
        }

        // Modify addResult function to update punctuation button
        const originalAddResult = addResult;
        addResult = function(text, isFinal) {
            originalAddResult(text, isFinal);
            updatePunctuationButton();
        };

        // Connect WebSocket on page load
        window.onload = function() {
            connectWebSocket();
        };
    </script>
</body>
</html>
